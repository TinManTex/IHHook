#pragma once

#include "MinHook.h"
#include "MemoryUtils.h"
#include <map>
#include <string>
#include <stdint.h>

#include "Hooking.Patterns/Hooking.Patterns.h"//DEBUGNOW

#include "spdlog/spdlog.h"

namespace IHHook {
	extern std::map<std::string, uint64_t> addressSet;
	extern std::map<std::string, void*> funcPtrPtrs;
	extern std::map<std::string, uint64_t> hookFuncs;

	//DEBUGNOW put this somewhere or CULL>
	//DEBUGNOW signatures are more robust to game updates/different game versions than straight addresses, but take a long time to search
	//since IHHook is started on it's own thread game initialisation will continue, and IHHook wont be ready in time to start up IH properly.
	//an alternative would be to do a hook to an early execution point of the game and init  ihhook there,
	//but given the low rate of updates of the game it's better to stick with direct addresses, but have signatures documented as a backup

	// Function addresses are from IDA/Ghidra, which uses the ImageBase field in the exe as the base address (usually 0x140000000)
	// the real base address changes every time the game is run though, so we have to remove that base address and add the real one
	// so it's rebased when its set up (see GET_REBASED_ADDR for the simple rebasing math)

	//Signatures currently grabbed using GH SigMaker
	//https://guidedhacking.com/resources/guided-hacking-x64-cheat-engine-sigmaker-plugin-ce-7-2.319/
	//DEBUGNOW only need one type sig&mask or pattern, but have yet to decide on which to use (sigmaker grabs both so there's no real issue on generating
	//though I prefer pattern for easier manual comparing without having to jump back and forth between sig and mask, seems all the sigmatching funcs I have currently gathered so far are sig&mask

	//DEBUGNOW update this
	//also document isTargetExe
	//<

	//tex macros still usefull because you can reference the function pointers rather than strings
	//and vs intellisense is great these days if you want to know what is actually happening

	//name: original function name as exported from ghidra, including namespace
	//hookFunc: the hook function you are using for this function
	//CREATEHOOK(lua::lua_newstate,lua_newstateHook);
	#define CREATE_HOOK(name,hookFunc) CreateHook(#name,hookFunc)

	#define ENABLE_HOOK(name) EnableHook(#name)

	#define DISABLE_HOOK(name) DisableHook(#name)

	#define HAS_ADDRESS(name) HasFunctionAddress(#name)

	//You can use the macro CREATEHOOK instead which tidys away use of string
	//targetName: name of original function (as exported by ExportInfo) (namespaced as original)
	//hookFunc: pointer to your hook function
	static MH_STATUS CreateHook(const char* targetName, LPVOID hookFunc) {
		LPVOID* address = (LPVOID*)addressSet[targetName];
		if (address == NULL) {
			spdlog::error("CreateHook: could not fine addressSet[{}]", targetName);
			return MH_UNKNOWN;
		}
		//tex since hooking pushes the original function out of its address for the hooked function,
		//MH_CreateHook can take in the funcptr that we use to call the original functions and update it to where it put it
		//and since the ihhook system is already abstracted a bit through address map, we also have a map to those funcptrs 
		//funcPtrPtrs, which set up in SetFuncPtrs which is generated by ExportInfo script.
		//which means we dont have to rely on macro just to point to the global funcptr for that function
		LPVOID* funcPtrPtr = (LPVOID*)(funcPtrPtrs[targetName]);
		if (funcPtrPtr == NULL) {
			spdlog::error("CreateHook: funcPtrPtrs[targetName]==NULL, CreateHook should not be called before SetFuncPtrs", targetName);
			return MH_UNKNOWN;
		}
		MH_STATUS createStatus = MH_CreateHook(address, hookFunc, funcPtrPtr);
		if (createStatus != MH_OK) {
			spdlog::error("MH_CreateHook failed, not MH_OK for {}", "foxlua::NewModule");
		}
		else {
			hookFuncs[targetName] = (uint64_t)&hookFunc;
			spdlog::debug("MH_CreateHook MH_OK for {}", "NewModuleHook");
		}
		return createStatus;
	}//CreateHook

	//You can use the macro ENABLEHOOK instead which tidys away use of string
	//targetName: name of original function (as exported by ExportInfo name) (namespaced as original)
	//Example use:
	//EnableHook("lua::lua_newstate");
	static MH_STATUS EnableHook(const char* targetName) {
		uint64_t address = addressSet[targetName];
		if (address == NULL) {
			spdlog::error("IHEnableHook: Could not find addressSet[{}]", targetName);
			return MH_UNKNOWN;
		}

		MH_STATUS enableStatus = MH_EnableHook((LPVOID*)address);

		if (enableStatus != MH_OK) {
			spdlog::error("MH EnableHook failed for {} with code {}", targetName, enableStatus);
		}
		else {
			spdlog::debug("MH EnableHook MH_OK for {}", targetName);
		}
		return enableStatus;
	}//EnableHook

	//You can use the macro DISABLEHOOK instead which tidys away use of string
	static MH_STATUS DisableHook(const char* targetName) {
		uint64_t address = addressSet[targetName];
		if (address == NULL) {
			spdlog::error("IHEnableHook: Could not find addressSet[{}]", targetName);
			return MH_UNKNOWN;
		}

		MH_STATUS enableStatus = MH_DisableHook((LPVOID*)address);

		if (enableStatus != MH_OK) {
			spdlog::error("MH DisableHook failed for {} with code {}", targetName, enableStatus);
		}
		else {
			spdlog::debug("MH DisableHook MH_OK for {}", targetName);
		}
		return enableStatus;
	}//DisableHook
}//namespace IHHook
